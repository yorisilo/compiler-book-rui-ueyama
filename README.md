# 低レイヤを知りたい人のためのCコンパイラ作成入門
* [低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)

``` shell
$ docker build -t compilerbook https://www.sigbus.info/compilerbook/Dockerfile

$ docker run --rm -v $(PWD):/9cc -w /9cc compilerbook make test
or
$ docker run -it --rm -v $(PWD):/9cc -w /9cc compilerbook
```

# 機械語とアセンブラ
以下で説明するアセンブリは x86-64 を

## CPUとメモリ
コンピュータを構成するコンポーネントは大きく CPU メモリ に分けることができる

* CPU
メモリを読み書きしながら、何らかの処理を行っていくデバイス

* メモリ
データを保持できるデバイス
CPU にとって、メモリはランダムアクセス可能な巨大なバイトの配列のように見えている。

* アドレス
CPU がメモリにアクセスするときに、メモリの何番目に対してアクセスするかを数値で指定する。その数値のこと
ex. アドレス16から8バイトのデータを読む

* プログラム、データ
CPU が実行するプログラムやそのプログラムが読み書きするデータはメモリに入っている。

* PC(プログラムカウンタ)、IP(インストラクションポインタ)
現在実行中の命令のアドレスのこと
CPU は現在実行中の命令のアドレスをCPU内部に保持していて、そのアドレスの命令を読み出し、命令を実行し、次の命令を読み出し実行する…ということを繰り返す。

* 機械語
CPU が直接実行する命令を表した言語

* 命令セット
特定の機械語の命令の総称
命令セットはCPUごとに用意されている。
機械語レベルで互換性がないと同じプログラムを動かすことはできないので、一般的に用いられる命令セットのバリエーションは少ない。
ex. PC では x86-64 が多く, iphone や android では ARM を使っている。

* 分岐、ジャンプ
プログラムカウンタを次の命令以外の場所に設定すること
プログラムカウンタは、直線的に次の命令に進むだけでなく、分岐命令を使うと次の命令以外の任意のアドレスを読みに行くこともできる。
この機能によって いわゆる if 文やループを実現する。

* レジスタ
CPU はプログラムカウンタ以外にも、小さいデータ保存領域を持っている。その領域のこと
ex. intel や AMD のプロセッサーは 64 bit 整数が保存できる領域を16個持っている。
メモリはCPUの外部のデバイスなので、読み書きするのに多少の時間がかかるが、レジスタはCPU内部にあるので、遅延なしにアクセスできる。

* CPU の命令
多くの CPU 命令は、2つのレジスタの値を使って、何らかの演算を行った結果をまたレジスタに書き戻すということを行う。

* プログラムの実行
CPUがメモリからレジスタにデータを読み込み、レジスタとレジスタの間で何らかの演算を行い、その結果をメモリに書き戻すということを繰り返していくことでプログラムの実行が進んでいく

### 閑話休題：スタックとヒープ
* [メモリとスタックとヒープとプログラミング言語 | κeenのHappy Hacκing Blog](https://keens.github.io/blog/2017/04/30/memoritosutakkutohi_puto/)

## アセンブラ
アセンブリの記述方法として主に以下の2種類ある
* Intel 記法
* At&T 記法

> 表現力はAT&T記法もIntel記法も同じです。どちらの記法を使っても、生成される機械語命令列は同一です。

> gcc(g++)では、-Sオプションに加えて-masm=intelオプションを付けるとアセンブリソースがIntel記法になります。
> gdbではset disassembly-flavor intelコマンドで逆アセンブルソースがIntel記法になります。

アセンブラ: 機械語(バイナリ)とほぼ1対1になっている

プログラムが実行するまでの流れの例
`C言語 -> アセンブリ -> 機械語 -> CPUが理解、実行する`

cコンパイラ
* `c言語 -> cコンパイラ -> アセンブリ`

アセンブラ
* `アセンブリ -> アセンブラ -> 機械語`

CPU
* `機械語 -> CPU -> 処理結果`

> 仮想マシンやインタープリタではなくネイティブなバイナリを出力するコンパイラの場合、通常、アセンブリを出力することが目標になります。機械語を直接出力しているように見えるコンパイラも、よくある構成では、アセンブリを出力したあとにバックグラウンドでアセンブラを起動しています。本書で作るCコンパイラの出力もアセンブリです。

cf.
[誰でも機械語が読めてパソコンの基本的な仕組みが理解できるようになりそうな記事を書きました - Qiita](https://qiita.com/tk_01/items/a84408b5436ec97bfbe1)


objdump: 実行ファイルを逆アセンブルして、機械語とそれに対応するアセンブリを表示させるコマンド

実行例
``` shell
$ objdump -d -M intel /bin/ls
/bin/ls:     file format elf64-x86-64

Disassembly of section .init:

0000000000003d58 <_init@@Base>:
  3d58:  48 83 ec 08           sub    rsp,0x8
  3d5c:  48 8b 05 7d b9 21 00  mov    rax,QWORD PTR [rip+0x21b97d]
  3d63:  48 85 c0              test   rax,rax
  3d66:  74 02                 je     366a <_init@@Base+0x12>
  3d68:  ff d0                 call   rax
  3d6a:  48 83 c4 08           add    rsp,0x8
  3d6e:  c3                    ret
...
```

一行取り出してみる
``` shell
3d58:  48 83 ec 08           sub    rsp,0x8
```

3d58 というアドレスに `48 83 ec 08` という機械語が入っている。 `sub    rsp,0x8` はその機械語に対応するアセンブリである。
つまり、 プログラムカウンタが `0x3d58` のときに実行される。


アセンブリの出力方法
``` shell
# c言語のコードから、アセンブリを出力する
gcc -S hoge.c -o hoge.s
# アセンブリのバイナリを出力する
gcc hoge.s -o hoge
# 実行
./hoge
```

c言語に対応するアセンブリを見てみる

c
``` c
int main() {
  return 42;
}
```

アセンブリ

``` assembly
.intel_syntax noprefix # アセンブリの文法を指定する命令
.global main # main という関数が、ファイルスコープではなく、プログラム全体から見える関数ということを指定する命令
main:
        mov rax, 42 # mov 命令を使って 42 を RAX レジスタにコピーする
        ret # ret 命令を使って、関数の呼び出しもとのアドレスに戻る。(関数からリターンしたときにRAXに入っている値が関数の返り値という決まり)
```

## 関数呼び出し
> x86-64 は、関数を使ったプログラミングをサポートするために、スタックポインタ専用のレジスタ(rsp)とそのレジスタを利用する命令を用意している。

* [x86アセンブリ言語での関数コール](https://vanya.jp.net/os/x86call/#callret)

関数を使ったプログラミングをサポートするためにスタックはある

関数呼び出しはいくらでも深くできるので、リターンアドレス(関数の呼び出し元のアドレス)をメモリに記憶しておく必要がある。
そのリターンアドレスはメモリ上のスタックに記憶される。

スタックは、スタックの一番上のアドレス(スタックトップ)を保持する一つの変数のみを使って実装できる。

* スタックポインタ：スタックトップを保持する記憶領域

* rsp: スタックポインタ専用のレジスタ

rsp を利用するための命令
* push: スタックにデータを積む命令
* pop: スタックに積まれたデータを取り出す命令

関数呼び出しの例

c
``` c
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
```

アセンブリ

``` assembly
.intel_syntax noprefix
.global plus, main

plus:
        add rsi, rdi # rsi レジスタの値と rdi レジスタの値を加えて rsi レジスタにコピーする
        mov rax, rsi # rsi レジスタの値を rax レジスタにコピーする
        ret # スタックからアドレスを1つポップし、そのアドレスにジャンプする。

main:
        mov rdi, 3 # rdi レジスタに 3 をコピー
        mov rsi, 4 # rsi レジスタに 4 をコピー
        call plus # plus 関数を呼ぶ
        ret
```

アセンブラでは、 (intel記法の場合) 第1引数は、rdi レジスタ、第2引数は rsi レジスタに入れるお約束となっている。

* call: 関数を呼び出す命令、
  - call の次の命令のアドレスをスタックにプッシュ。上記の場合だと ret を スタックにプッシュする。
  - call の引数に与えられた命令のアドレスにジャンプする

* ret: 関数からのリターンを行う命令。つまり、ret は、 call の位置に戻り、呼び出し元の関数の実行を再開する命令
  - スタックからアドレスを1つポップする
  - そのアドレスにジャンプする

call と ret は対になる命令である。

> plusからリターンしたところにあるのはmainのret命令です。元のCコードではplusの返り値をそのままmainから返すということになっていました。ここではplusの返り値がRAXに入った状態になっているので、そのままmainからリターンすることで、それをそのままmainからの返り値にすることができます。

## まとめ
> * CPUはメモリを読み書きすることでプログラムの実行を進めていく
> * CPUが実行するプログラムと、そのプログラムが扱うデータは、どちらもメモリに入っていて、CPUはメモリから順に機械語命令を読み、その命令を実行する
> * CPUにはレジスタという小さな記憶領域があり、多くのCPU命令はレジスタ間での操作として定義されている
> * アセンブリは機械語を人間にとって読みやすくした言語で、Cコンパイラは普通はアセンブリを出力する
> * Cの関数はアセンブリでも関数になる
> * 関数呼び出しはスタックを使って実装されている

# 電卓レベルの言語の作成
* 構文解析の最も一般的なアルゴリズムの一つである「再帰下降構文解析法」を使ってparserを作る。
